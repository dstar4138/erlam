// An "Async" storage unit.
//   This program will start a cell and a couple consumers and producers which
//   will all concurrently sync with the cell trying to add or remove from the
//   cell's stack.

let num_of_consumers = 5 in
let num_of_producers = 5 in

// Church Encoding for lists, augmented for integer values.
// --------------------------------------------------------------------------
let nil_list = snd                               in let
    cons = fun x,y,z.(z x y)                     in let
    head = fun l.(l fst)                         in let
    tail = fun l.(l snd)                         in let
    is_nil = fun l.(unrep (l fun h,t,d.snd fst)) in 

// The Async Cell which will handle messages as they come and respond directly.
// Each action requires two swaps, see below for the API of the async send/recv.
// --------------------------------------------------------------------------
let cell = fun chan,_.
        (omega fun f,l.
                // First listens on channel for first message:
                let message = (swap chan nil) in

                // Message will be a pair, the action and the channel to 
                // send the result back over on:
                let action = (fst message) in
                let hidden_chan = (snd message) in
                
                // Message will then be run on the list, result is a pair of
                // ( Return_val, NewList ), which we access below:
                let result = (action l) in
                let return = (fst result) in
                let newlist = (snd result) in

                // Now we swap back the return on the hidden channel and 
                // recurse with the new list:
                let _ = (swap hidden_chan return) in (f f newlist)) in
in
    // Actions that can be taken on the internal list. Note all actions must
    // return the (return_val, newlist) list so the cell can take action.
    let push = fun a,l.( 
                    let newlist = (cons a l) in
                    let return = nil in 
                    (cons retun (cons newlist nil_list)))
    let pop = fun l.(
                    let check = (is_nil l) in
                    let newlist = if check nil_list (tail l) in
                    let return = if check nil (head l) in
                    (cons return (cons newlist nil_list))) 
in

// An "Async" Channel, still blocking on the swap, but it breaks up the logic
//  of sending and receving data.
// ------------------------------------------------------------------------
let mksocket = fun send_channel.
                    let recv_channel = newchan in
                        (omega fun f,action.(action send_channel recv_channel))
in

    // Blocking send on a socket (simulated async)
    let send = fun socket,item.
                    (fun s,r. // socket will pass action send/recv channels.
                        let msg = (cons item (cons r nil_list))
                        in (swap msg s)) in

    // Blocking recv on a socket (simulated async)
    let recv = fun socket.
                    (fun s,r. // socket will pass action send/recv channels.
                        (swap r nil)) 

in

// A General purpose actor will randomly hang for 1-10 seconds before 
// performming the action on the cell.
let actor = fun action,cell_comm,_. (omega fun f. 
                                (ignore (rhang 10) (action cell_comm)))
in

// A Producer will generate random items to add after "thinking" for some time
// and then attempt to add it to the cell.
let producer = (actor (fun cell_comm.(ignore (send (push (rand 1000)) cell_comm)
                                             (print (recv cell_comm)))))
in

// A Consumer will ask for the top item of the list 
let consumer = (actor (fun cell_comm.(ignore (send pop) 
                                             (print (recv cell_comm)))))
in

/// MAIN::::::
    let cell_channel = newchan in
    let _ = (spawn (cell cell_channel)) in
    let pspawner = fun _.(spawn (producer cell_channel)) in
    let cspawner = fun _.(spawn (consumer cell_channel)) in

    // Spawn N producers and M consumers to act on the cell.
    (ignore (rep num_of_producers pspawner nil)
            (rep num_of_consumers cspawner nil))
    

